# Замена
Аутор: 
Текст и тест примери: 
Анализа решења: Александар Вишњић
Тестирање: 

### Први подзадатак:
Задатак решавамо динамичким програмирањем. Нека $dp_i$ представља максималан број бодова који је могуће остварити ако Пиксел завршава са памћењем на индексу $i$. Одговор на задатак је максимална вредност низа $dp$. Рекурентна једначина је
$$dp_i=max(dp_j+f(i,j) | j<i)$$
где функција $f(i,j)$ представља колико се бодова добија ако се са претходно запамћеног броја на позицији $j$ запамти број $i$. Она такође износи $-\infty$ ако се нови број разликује од старог за више од једне цифре (немогућ случај). Сложеност овог алгоритма је $O(N^2 \cdot C)$, где је $C$ број цифара сваког броја.

### Други подзадатак:
Користимо сличну идеју, али приметимо да је број различитих вредности $A_i$ мали. Нека $dp_{i,j}$ сада представља максималан број бодова који је могуће остварити на префиксу низа $A_1,...,A_i$ ако је последњи запамћен број једнак $j$. Рекурентна једначина је 
$$dp_{i,j}=max(dp_{i-1,k}+f(A_i,k))$$
Функција $f(a,b)$ се слично дефинише као раније - број бодова који се остварује датим прелазом. Временска и меморијска сложеност је $O(N\cdot maxAi)$.

### Главно решење:
Користићемо слично решење као и раније. Најпре, приметимо да има највише $10\cdot C$ различитих могућности за стари број ако посматрамо неки одређени нови који памтимо ($C$ је број цифара). Направимо низ $dp_i$ који представља матрицу из другог подзадатка, само што нећемо памтити ништа за префикс него ћемо је редом попуњавати како бисмо уштедели меморију. То значи да за дато $i$ рекурентна једначина постаје
$$dp_{A_i}=dp_k+f(A_i,k)$$
где је $k$ свака могућа могућност старог броја за које смо раније рекли да их нема много. Временска сложеност је $O(N\cdot C\cdot L)$, а меморијска $O(maxAi)$. $L$ представља број различитих цифара у декадном систему, односно износи $10$
