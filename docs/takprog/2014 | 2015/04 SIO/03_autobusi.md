# Аутобуси

Аутор: 
Текст и тест примери: 
Анализа решења: Александар Вишњић
Тестирање: 

### Први подзадатак:
Сваким упитом пролазимо једном кроз низ $A$. Направићемо помоћни *bool* низ $B$ који нам служи да памтимо претходно посећене станице у том проласку. $A$ се по дефиницији дели на дисјунктне сегменте који означавају по једну аутобуску линију, стога када прођемо кроз један такав сегмент потребно је опет проћи и маркирати све његове станице као непосећене, пошто се сваки сегмент решава засебно. Када наиђемо на $Y_i$, потребно је само проверити да ли је станица $X_i$ већ посећена. (Напомена: број решења се повећава највише једном по сегменту/аутобуској линији) Временска сложеност је $O(Q\cdot M+N+W)$, а меморијска $O(W)$.

### Други подзадатак:
Правимо две помоћне матрице $L[i][j]$ и $R[i][j]$ које, редом, означавају прво и последње појављивање станице $j$ у линији $i$. Број $-1$ означава да таква станица не постоји. Сада за сваки упит можемо једноставно проверити да ли се $X_i$ налази пре $Y_i$ у свакој од $N$ аутобуских линија. Временска сложеност је $O(N\cdot W+N\cdot Q+M)$, а меморијска $O(N\cdot W)$.

### Трећи подзадатак:
Израчунаћемо за сваке две станице број линија, па ћемо одговарати на упите у $O(1)$. За ефикасно рачунање ћемо по свакој линији засебно проћи по свим паровима станица у њој и одредити да ли је могуће да се једна нађе пре друге. (Рачунамо само једниствене станице у линији)

Ово ради у $O(len_i^2)$ времену по линији $i$ која има $len_i\leq W$ станица. Нека је $f(len_1,len_2,...,len_N)=\sum_{i=1}^N len_i^2$. Није тешко видети да важи $f(...,len_i+1,...,len_j-1,...)>f(...,len_i,...,len_j,..)$ ако је $len_i\geq len_j$ и $i\neq j$. (Не мора да важи $i<j$ као у примеру горе, битно је само да су различити индекси) Из овога непосредно следи $f(len_1,...,len_N)\leq f(W,...,W,0,...,0)$. У другој функцији се $W$ појављује не више од $\frac{M+W}{W}$ пута, па важи $f(W,...,W,0,...,0)\leq (M+W)\cdot W$ и то је наше горње ограничење за број операција.

Временска сложеност је $O(M\cdot W+W^2 + N+Q)$, а меморијска $O(W^2)$.

### Четврти подзадатак:
Направимо два низа **мапа** $L$ и $R$ величине $N$. У њима за сваку аутобуску линију и станицу у њој памтимо њено прво и последње појављивање у оквиру дате линије. Такође, правимо низ **скупова** $S$ величине $W$. У њему за сваку станицу одређујемо које све линије пролазе кроз њу. На упите одговарамо на следећи начин:

Ако смо већ одговорили на упит $(X_i,Y_i)$, само ћемо узети претходно запамћено решење. (ово је неопходно јер ће рачунање нових одговора бити споро, а битно је гарантовати да они буду различити) За нов упит ћемо једном проћи кроз **мањи** од скупова $S[X_i]$ или $S[Y_i]$, и за сваку његову аутобуску линију одредити да ли се $X_i$ налази пре $Y_i$.

Ово на први поглед изгледа као да ради у $O(Q\cdot N)$ времену са малом константом. Доказаћемо да то није случај. Нека низ $s_i$ представља колико смо пута прошли кроз скуп $S[i]$. Можемо надаље претпоставити, без умањења општости, да је дат низ скупова сортиран у нерастућем поретку по њиховим величинама. Како никад не питамо два иста скупа више од двапут, и како увек питамо **мањи** од два скупа, можемо закључити $s_i \leq2( i-1)$ за свако $1\leq i \leq W$. Укупан број операција износи $\sum s_i\cdot S[i].size$ , а максимум се управо постиже за $s_i=2(i-1)$, $1\leq i \leq \sqrt{Q}$. (Отприлике, мoра да важи $\sum s_i=Q$, а $2\cdot \sum_{i=1}^{\sqrt{Q}} (i-1)$ превазилази $Q$) Када бисмо могли да мењамо величине скупова из низа $S$ пребацивањем једног елемента у други, повећао би се укупни број операција када би се повећао и скуп са више проласка. (тј. већим бројем $s_i$) Овим се на крају доbија да највећи укупан број операција није већи него у случају у ком важи $S[1].size=S[2].size=...=S[Q].size= \sqrt{N}$, због поретка величина. Алгоритам ће извршити највише $O(Q\sqrt{N})$ операција.

Ако користимо **std::map** и **std::set**, укупна временска сложеност је 
$O(Q\cdot \sqrt{N}\cdot logN +N+M+W )$ , а меморијска $O(N+M+W)$.

### Главно решење:
 
Решење је исто као и  у четвртом подзадатку, само ћемо уместо **std::set** и **std::map** користити **std::unordered_set** и **std::unordered_map**, чиме се временска сложеност побољшава на $O(Q\cdot\sqrt{N}+N+M+W)$. Задатак се такође може решити и **offline** нешто брже тако што ћемо постојање линије која пролази кроз неку станицу одредити накнадно, али имплементација тога је мало тежа. Све у свему, укупна временска сложеност је $O(Q\cdot\sqrt{N}+N+M+W)$, а меморијска $O(N+M+W)$.
