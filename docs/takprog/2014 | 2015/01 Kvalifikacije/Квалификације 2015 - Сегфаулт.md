
# Segfault

  

Аутор: 

Текст и тест примери: 

Анализа решења: 

Тестирање:

  

### Решење за $N,M,K \le 600$:
Како Перица може да пусти бесконачно много програма, а програма дужине $N\cdot M$ има коначно много, можемо да претпоставимо да ће Перица да пусти све њих. То значи да ако је Перција заузео неко поље, он ће у следећем потезу заузети сва његова суседна поља, осим ако их Николај или корисник машине није већ заузео. 

За овај подзадатак је доста да се ради симулација Перициног заузимања, што може да се уради преко BFS-a. Само треба за свако поље које Перица заузме да се провери да ли га је Николај заузео пре њега, што можемо да урадимо преко for петље.

Временска сложеност је $О(N\cdot M\cdot K)$.

### Решење за $K \le 1000$:
Овде је неопходно одратити прекалкулацију. За свако поље, треба да одредимо тренутак када ће неки од Николајевих програма да заузме то поље под претпоставком да их пре тога не заузме Перица. Та прекалкулација може да се уради двоструком петљом у сложености $O(K \cdot max(N,M))$. 

Након тога ћемо пустити BFS као у прошлом подзадатку. Али, уместо да проверавамо петљама да ли је Николај већ заузео то поље, можемо да погледамо да ли је прекалкулисано време заузимања мање или једнако од времена када Перицин програм стигне на то поље.

Укупна временска сложеност је $О(K \cdot max(N,M) + N\cdot M)$.

### Главно решење:

Главна идеја је да ако програм који иде на неку страну дође на поље где је био неки други програм који иде на исту ту страну, оригинални програм може да престане са радом пошто ће други програм доћи на свако следеће поље пре њега. Са овом модификацијом, сложеност прекалкулације је амортизовано $О(N \cdot M + K)$, a укупна сложеност $О(N\cdot M + K)$.
