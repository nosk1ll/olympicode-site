# Бројање

Аутор: 
Текст и тест примери: 
Анализа решења: 
Тестирање:

Подниз низа $A$ од индекса $i$ до индекса $j$ означавамо са $[i,j]$, где је $1 \leq i,j \leq N$.

### Решење за $1 \leq N,Q,A_i \leq 10$:
Довољно је за сваки упит испробати сваки могући подниз узастопних бројева.

### Решење за $1 \leq N,A_i \leq 1000$ :
Можемо за сваки подниз $[i,j]$ наћи највећи број у њему $M$ и повећати број поднизова са максималним елементом $M$ за један. Тада на упите одговарамо у константном времену. Временска сложеност: $O(N^2+Q)$, меморијска сложеност: $O(N)$.

### Решење за $1 \leq N \leq 100$ :
Можемо користити исто решење као у претходном подзадатку уз измену да уместо низа за бројање поднизова са максималним елементом $M$ користимо *C++ map*-у. Временска сложеност: $O(N^2 \cdot \log(10^{9})+Q \cdot \log(10^{9}))$, меморијска сложеност: $O(N)$.
 
### Главно решење:
Уколико желимо да баш елемент $A_i$ буде највећи број у неком поднизу, можемо то замислити као да почињемо од једночланог подниза $[i,i]$ који покушавамо да што је више могуће проширимо улево и удесно уз услов да његов највећи елемент остане $A_i$. Могуће је да при томе стигнемо до левог или десног краја низа. Другим речима, можемо пронаћи индексе $l$ и $r$ такве да је $1 \leq l \leq i \leq r \leq N$ и да за сваки индекс $j$ од $l$ до $r$ важи $A_j \leq A_i$, и на крају, да важи или да је $l=1$ или $A_{l-1} > A_i$ као и да важи или $r=N$ или $A_{r+1} > A_i$. Нека $L_i$ и $R_i$ означавају управо ове јединствене вредности $l$ и $r$ за фискиран индекс $i$.

Вредности $L_i$ и $R_i$ можемо израчунати помоћу структуре података попут *C++ stack*-а. Следећи псеудокод представља алгоритам за проналажење $R_i$ (за $L_i$ је  поступак сличан):

```
S #prazan stek
for i = 1 . . . n:
	while(!S.empty && a[i] > a[S.top]) #dodeljujemo vrednosti R[i] manjim elementima u steku
		R[S.top] = i-1
		S.pop
	S.push(i)
	
while(!S.empty)
	R[S.top] = N
	S.pop
```

Ове вредности нам говоре докле је дозвољено продужити подниз у обе стране тако да највећа вредност и даље остане $A_i$. Зато је број поднизова у којима је највећи елемент баш $A_i$ једнак $$C_i=(i-L_i+1) \cdot (R_i-i+1)$$ јер је било која комбинација дозвољених продужења једночланог подниза $[i,i]$ улево и удесно валидна - улево смемо продужити за највише $i-L_i$ позиција а удесно за највише $R_i-i$ позиција.

Када би сви елементи низа били различити, решење би просто било $\sum_{i=1}^{N} C_i$. Међутим, када постоје једнаки елементи, може се десити да смо у вредностима $C_i$ за различите индексе бројали исте поднизове више пута. На пример, ако се вредност $v$ појављује тачно два пута, тј. $A_p = A_q=v$ за $p < q$,  и ако је $L_q \leq p$ тада се неки поднизови које смо бројали у $C_q$, а који садрже $A_p$, појављују и у $C_p$. Штавише, како је $L_q \leq p$, онда мора важити и $R_q \geq q$, па смо,  у ствари, све поднизове које смо бројали у $C_q$, а који садрже $A_p$, бројали и у $C_p$ (чак важи и потпуна једнакост ових параметара, тј. $L_p=L_q$ и $R_p=R_q$, али то је мање важно). Ово запажање олакшава ствари јер сада број поднизова у којима је $v$ највећа вредност, без вишеструког бројања истих поднизова, можемо добити као $C_p+C_q^{\prime}$, где је $C_q^{\prime}$ иста вредност $C_q$, али израчуната користећи $L_q^{\prime}=p+1$ уместо старе вредности $L_q$, тј. $C_q^{\prime}=(q-(p+1)+1) \cdot (R_q-q+1)$.

Чак и ако се догоди да постоје више од два појављивања вредности $v$ у низу, на позицијама $p_1,p_2, \dots  ,p_k$ ($1 \leq p_1 < p_2 < \dots < p_k \leq N$), број поднизова у којима је $v$ највећа вредност, без вишеструког бројања истих поднизова, ће бити $$T_v=C_{p_1}+\sum_{j=2}^{k} C_{p_j}^{\prime}$$ где је $C_{p_j}^{\prime}$ вредност $C_{p_j}$ израчуната користећи $L_{p_j}^{\prime}=p_{j-1}+1$ уместо старе вредности $L_{p_j}$ у случају да важи $L_{p_j} \leq p_{j-1}$, или само $C_{p_j}$ иначе. Значи:

$$C_{p_j}^{\prime}=\left\{
\begin{array}{l}
      (p_j-(p_{j-1}+1)+1) \cdot (R_{p_j}-p_j+1), \text{ ако }  L_{p_j} \leq p_{j-1}\\
      C_{p_j}, \text{ иначе}
\end{array}
\right.
$$
Дакле, ако лева граница за проширивање подниза $[i,i]$ тренутног елемента $A_i$ обухвата претходни елемент исте вредности $A_j$ $(j < i)$, довољно је на овај начин променити $L_i$ да бисмо избегли вишеструко бројање. Сада можемо израчунати $T_v$ за сваку вредност $v$ која се појављује у низу, чувати је у *C++ map*-и и тако дати одговор на сваки од $Q$ упита у $O(\log (10^{9}))$. 

Временска сложеност: $O((N+Q) \cdot \log(10^9))$, меморијска сложеност: $O(N)$.
