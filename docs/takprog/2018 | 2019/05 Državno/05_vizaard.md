## Анализа

На почетку, констатујмо да ни у једном оптималном решењу нећемо примењивати оба типа операција на исти број – или ћемо само повећавати, или само смањивати тај број. 

Приметимо да, уколико желимо да је and свих елеманата већи од 0, мора постојати једна позиција на којој сви бројеви имају бинарну цифру 1. Уколико фиксирамо ту позицију t, можемо израчунати за сваки број у константном времену најмањи број додавања број 1 на њега тако да у том броју цифра на позицији t постане 1. Такође, можемо израчунати и најмањи број одузимања потребан за исту ствар. Оптимално нам је да изаберемо ону опцију за коју треба мање операција, али је такође корисно да сачувамо да ли је за неки број било могуће да узмемо било коју опцију (уколико је број додавања и одузимања исти).

Како смо испунили први услов (за фиксно t), прва следећа ствар коју треба проверити је да ли је xor свих овако добијених бројева 0 – ако јесте, нашли смо најмањи број операција за изабрану позицију. Уколико није, а постојала је друга опција за неки број, искористићемо њу и она ће променити xor, тако да није потребно додатних операција, уколико није постојала, требаће нам још 2 или 1 операција, у зависности од тога да ли је t изабрана позиција најдеснија или није.

Урадивши ово за свако t од 0 до 60 (максимални број битова), све што нам је преостало је да узмемо минимум добијених бројева операција.

Временска сложеност: $O(NlogMAX)$, где је MAX максималан број у улазу (10^18).
