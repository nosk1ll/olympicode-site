# 4 -  Konjugacija

| Autor | Tekst i test primeri | Analiza rеšenja | Testiranje |
|:-:|:-:|:-:|:-:|
| Nikola Milosavljević | Nikola Milosavljević | Nikola Milosavljević | Momčilo Tošić |

Možemo za svaki par segmenata proveriti u konstantnoj složenosti da li su konjugovani - složenost ovog algoritma je $O(N^2)$, što je dovoljno za **Podzadatak 1**

Ako su koordinate krajeva segmenata brojevi ne veći od $MaxVal$, tada postoji $O(MaxVal^2)$ mogućih pozicija za segmenate. Možemo u nekoj pomoćnoj matrici $m$ pamtiti $m[i][j] =$ broj segmenata sa krajevima u $i$ i $j$. Zatim, slično kao i u prethodnom slučaju, za svake dve moguće pozicije segmenata proverimo da li su oni konjugovani i koliko je to ukupno parova na osnovu matrice $m$. Ukupna složenost je $O(N + MaxVal^4)$ što je dovoljno za **Podzadatak 2**

Jedna od ideja je sortirati segmente neopadajuće na osnovu koordinate centra $c_i = \frac{a_i+b_i}{2}$ i za svaki segment $i$ odrediti koliko ima segmenata levo od njega koji su konjugovani sa njim; konačno rešenje dobijamo kada saberemo ove količine za svaki segment. Broj takvih segemenata je jednak broju indeksa $j$ za koje važi $1 \leq j < i$ i $a_i \leq c_j$ i $c_i \leq b_j$.

U **Podzadatku 3** su segmenti već sortirani rastuće po oba kraja posebno (pa samim tim i po centru) pa je skup segmenata levo od $i$-tog i koji su konjugovani sa $i$-tim neki uzastopni podniz sortiranog niza segmenata. U svakom koraku se sa početka ovog podniza mogu izbacivati segmenti koji nisu konjugovani sa trenutnim (neće biti konjugovani ni sa "desnijim" segmentima zbog uslova podzadatka) pa tehnika dva pokazivača i/ili binarne pretrage rešava ovaj podzadatak u složenosti $O(N)$ ili $O(N \log N)$.

Pretpostavimo da su sve koordinate centara $c_i$ relativno mali, različiti celi brojevi (možemo se obezbediti da budu celi tako što na početku pomnožimo sve krajeve segemenata sa $2$). Definišimo niz $A$ gde je za svako $i=\overline{1,N}$, $A[c_i] = r_i$ a na ostalim pozicijama su nule. Ako je $c_1 < c_2 < \ldots < c_N$, tada je broj segmenata koji su levo od segmenta $i$ i koji su konjugovani sa njim jednak broju elememenata uzstopnog podniza $A[l_i], A[l_i+1],\ldots, A[c_i - 1]$ koji su veći ili jednaki od $c_i$ (posmatra se samo podniz od $l_i$-te do $(c_i-1)$-te pozicije jer su indeksi - centri segmenata i oni moraju pripadati $i$-tom segmentu; vrednosti elementa su desni krajevi tih segmenata pa moraju biti $\geq c_i$ da bi sadržali centar $i$-tog segmenta). 

Ovim se zadatak svodi na **relativno poznat problem**: *dat je niz $A$ dužine $M$ i $N$ upita oblika $(l, r, k)$ - odrediti koliko ima elemenata u podnizu $A[l..r]$ koji su veći ili jednaki $k$*. Ovaj problem se najlakše rešava *offline* koristeći strukturu *segmentno stablo*. Na početku napunimo pomoćni niz $B$ nulama i sortiramo sve elememente i upite (zajedno) opadajuće po vrednosti elementa odnosno vrednosti $k$ u upitima. Zatim idemo redom po sortiranom nizu i kada naiđemo na neki element $A[i]$, na poziciji $i$ u nizu $B$ postavimo jedinicu; kada naiđemo na upit $(l,r,k)$, samo odredimo broj (ili zbir) svih elemenata u nizu $B$ na pozicijama od $l$ do $r$ jer su u tom trenutku dodati samo elementi iz $A$ koji su veći ili jednaki $k$. Ovo se jednostavno radi segmentnim stablom u ukupnoj složenosti $O(M + N \log M)$.

U **Podzadatku 4** su vrednosti $c_i$ zaista dovoljno male da se njima može direktno indeksirati niz $A$ (tj. ovde je $M \leq 10^6$) a slučajevi se jednakim $c_i$-ovima se rešavaju malom modifikacijom algoritma. Kada su vrednosti $c_i$ velike (npr. do $10^9$) treba koristiti *implicitno segmentno stablo* ili, jednostavnije, kompresovati koordinate na početku, što daje algoritam složenosti $O(N \log MaxVal)$ ili $O(N \log N)$ koji rešava **sve podzadatke**. 

Alternativni pristup (za rešavanje problema na koji smo sveli originalni problem) je korišćenje takozvane $Sqrt$-dekompozicije gde delimo niz na $\sqrt{N}$ delova veličine $\sqrt{N}$ i za svaki od njih pamtimo sortirani niz elemenata iz tog dela. Kada dođe upit $(l,r,k)$, za najviše dva dela u kojima su krajevi upita odradimo pretragu ručno a za ostalih $O(\sqrt{N})$ delova odradimo binarnu pretragu nad odgovarajućim nizom. Ovo daje algoritam složenosti $O(N\sqrt{N}\log N)$ koji bi, uz pristojnu implementaciju, takođe trebalo da osvoji sve poene. Napomenimo da ovaj pristup u istoj složenosti rešava varijantu problema u kome se zahteva da se na upite odgovara u zadatom redosledu (*online*) i gde su dozvoljeni upiti koji modifikuju pojedinačne elemente (inače, ova teža varijanta problema se može rešiti i u složenosti $O(N \log^2 N)$).
