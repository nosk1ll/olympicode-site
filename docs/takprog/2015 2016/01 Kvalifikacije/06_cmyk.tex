\documentclass[a4wide]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphics}
\usepackage{fancyhdr}
\usepackage{array}
\usepackage{paralist}
\usepackage{epsfig}
\usepackage[algopart]{algorithm2e}
\usepackage{subfig}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{hyperref}
\usepackage{amsfonts}
\usepackage{listings}
\usepackage{slashbox}
\pagestyle{fancy}
\usepackage[svgnames]{xcolor}
\usepackage{framed}

\definecolor{shadecolor}{named}{LightGray}

\textwidth 160mm \textheight 225mm
\setlength{\hoffset}{-25mm} \setlength{\voffset}{-20mm}
\setlength{\headwidth}{\textwidth} \setlength{\headheight}{20mm}

\lhead{Квалификације за Окружно такмичење из програмирања \\ 24 -- 31. јануар 2016. \vfill}
\rhead{\includegraphics[width=0.1\linewidth]{logo.png}}

\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\lstdefinestyle{classic}{showspaces=false, showstringspaces=false, basicstyle = \footnotesize\ttfamily, frame = single, backgroundcolor=\color{backcolour} }

\begin{document}

\noindent {\bf Назив проблема:} CMYK\\ \\
%
\begin{tabular}{l l}
{\it Аутор:} & Петар Величковић\\
{\it Анализа:} & Никола Јовановић\\
{\it Тагови:} & динамичко програмирање\\
\end{tabular}\\ \\ \\
%

\noindent[Draft 1 - Neke stvari ce moci biti popunjene posle kraja kvalifikacija i kad se dogovorimo oko biltena. Treba srediti pseudokod.]\\

\noindent {\bf Извор и идеја:}\\ \linebreak
Проблем {\bf CMYК} је постављен као најтежи проблем на овогодишњим квалификацијама. Статистика [link ka statistici, gde god bila (u ovom resenju, u biltenu negde)] показује [valjda] да је овај проблем заиста највише намучио такмичаре (само $X$ такмичара има максималан број поена). \\
\\
Теоријску основу овог задатка представља проблем {\bf парсирања контекстно-слободних граматика} (eng. \href{https://en.wikipedia.org/wiki/Context-free_grammar}{context-free grammars}). Конкретно, граматика дата у задатку је представљена у {\bf Чомски нормалној форми} (eng. \href{https://en.wikipedia.org/wiki/Chomsky_normal_form}{ Chomsky normal form}) па је парсирање могуће (уз мале модификације) извршити алгоритмом \href{https://en.wikipedia.org/wiki/CYK_algorithm}{ \bf{ Cocke–Younger–Kasami (CYK)} }, чије име се крије у наслову задатка. Иако чине теоријску основу овог задатка, увођење поменутих појмова из области формалних језика није неопходно, будући да је за разумевање CYK алгоритма са потребним модификацијама и комплетно решавање овог задатка потребно само познавање динамичког програмирања. Стога, тај део ћемо заобићи, и како би решење било јасније и разумљиво такмичарима који нису упућени у поменуту теорију у наставку анализе ћемо одступати од формалне терминологије. \\

\noindent {\bf Оптимално решење:}\\

\noindent Као што је већ поменуто, оптимално решење за овај задатак (и једино које је примећено међу решењима са максималним бројем поена [valjda]) се базира на {\bf CYK} алгоритму. Иако овај алгоритам ``има име'', очекује се да би такмичари који имају искуства са динамичким програмирањем требало да буду у стању да независно дођу до решења, без обзира на то што се нису раније сусрели са конкретним алгоритмом. CYK алгоритам у својој основној форми као улаз узима низ правила налик онима у задатку (тј. контексно-слободну граматику у Чомски нормалној форми), стринг {\tt S}, и стартни симбол (у нашем случају то је симбол {\tt 'W'}) и проверава да ли је могуће коначном применом правила доћи од стринга {\tt S} до стартног симбола (тј. да ли {\tt S} припада језику који граматика дефинише). Сложеност овог алгоритма је $\mathcal{O}(n^3 * m)$, где је {\tt n} дужина стринга {\tt S} а {\tt m} број правила. У нашем случају, алгоритам може да одреди да ли се унети низ боја може свести на {\bf једну} белу боју, што није довољно, будући да треба проверити да ли се улазни низ боја може свести на низ белих боја произвољне дужине. У наставку ћемо овај проблем, који онемогућава директно коришћење CYK алгоритма, звати {\bf проблем низа} и поменућемо два приступа која га успешно решавају. Пре тога, објаснимо основну верзију CYK алгоритма примењену на овај задатак. \\

\noindent Најважније својство које CYK користи је да су сва правила облика {\tt XY $\to$ Z}. Знајући ово, главна идеја алгоритма је  да истражи све могуће начине да се стринг {\tt S} подели на два дела и покуша да примени једно од правила на симболе добијене трансформацијом тих делова. Међурезултати се чувају у тродимензионалном низу \textit{boolean} вредности {\tt DP}, где {\tt DP[i][j][k]} има вредност \textit{true} акко је могуће подстринг дужине {\tt i} који почиње на индексу {\tt j} коначном применом правила свести на симбол {\tt k}. У првом кораку се поставе вредности за све поднизове дужине $1$ (тј. {\tt  DP[1][j][k]} има вредност \textit{true} акко је {\tt s[j] = k}). Након тога, алгоритам обрађује подстрингове редом, растуће по њиховим дужинама, и покушава да сваки подстринг подели на два дисјунктна подстринга {\tt L} и {\tt R}, 
након чега проверава да ли постоји правило типа {\tt AB} $\to$ {\tt  C} такво да је се {\tt L} може трансформисати у симбол {\tt A} и да се {\tt R} може трансформисати у симбол {\tt B} (ове вредности се могу наћи у табели). Ако такво правило постоји, у табелу се уписује да је тренутни подстринг могуће трансформисати у симбол {\tt C}. Када алгоритам обради све подстрингове, укључујући и комплетан стринг {\tt S}, информацију о томе да ли се се {\bf S} може трансформисати у симбол {\tt W} читамо из {\tt DP[n][1][W]} (ако је стринг индексиран од позиције $1$). \\

\noindent Сада долазимо до поменутог ``проблема низа''. Како модификовати/надоградити овај алгоритам тако да тестира трансфомацију у низ симбола {\tt W} уместо у појединачни симбол? Творци задатка су дошли до два решења за овај проблем:
\begin{itemize}
\item {\bf CYK\_start}: Додавањем новог симбола \verb|^| на почетак стринга и правила \verb|^|{\tt W} $\to$ {\tt W} у скуп правила омогућавамо да се низови белих боја на почетку стринга (након \verb|^|), условно речено, ``сажму'' тј. да се низ симбола {\tt W} (стринг облика \verb|^|{\tt {W..W}}) може трансформисати у један симбол \verb|^|. Сада се наш услов мења, и ако CYK докаже да се модификовани стартни стринг може довести до симбола \verb|^|, знамо да је одговор ``{\bf YES}''.
\item {\bf CYK\_tiles}: Приступ који је већина [verovatno] такмичара користила. Овога пута не мењамо скуп правила и стринг већ из CYK табеле тривијално извлачимо све подстрингове који се могу трансформисати у {\tt W} и решавамо потпроблем: да ли је могуће тим подстринговима ``поплочати'' цео стринг {\tt S} (тј. да ли је могуће одабрати скуп дисјунктних подстрингова чија је унија цео стринг {\tt S} такав да се сваки од њих може трансформисати у {\tt W})? Јасно је да је решење потпроблема еквивалентно решењу задатка, а потпроблем се решава још једном применом динамичког програмирања, коришћењем рекурентне везе $T[i] = T[i - l_1] | \dots | T[i - l_n]$, где је $l_i$ дужина {\tt i}-тог подстринга који се може трансформисати у {\tt W}. Дакле, {\tt T[i]} се односи на поплочавање првих {\tt i} карактера стринга, па се решење налази у {\tt T[n]}.
\end{itemize}

\noindent Псеудокод CYK алгоритма са ``start'' модификацијом [kako se pise pseudokod na srpskom, pomoc]:\\

\begin{shaded}
\noindent Нека је улазни стринг {\tt S} дужине {\tt n}: $a_1...a_n$.\\
Нека је скуп дозвољених симбола $[A..Z, \verb|^|]$.\\
Нека имамо {\tt m} правила облика $A \to BC$.\\
Нека је $DP[n, n, r]$ матрица boolean вредности, где су све вредности на почетку false.\\
\linebreak
for each j = 1 tо n:\\
\indent set $DP[1, j, a_j]$ = true\\
for each i = 2 to n: -- дужина подстринга\\
\indent for each j = 1 to n-i+1: -- почетни индекс\\
\indent \indent for each k = 1 to i-1: -- дужина првог сегмента\\
\indent \indent \indent for each $A \to BC$:\\
\indent \indent \indent \indent if $DP[k,j,B]$ i $DP[i-k,j+k,C]$ then set $DP[i,j,A]$ = true\\
		  \linebreak
if $DP[n, 1, \verb|^|]$ is true \\
\indent одговор је {\bf ``YES''}\\
else\\
\indent одговор је {\bf ``NO''}\\
\end{shaded}

\noindent Погледајмо сада илустрацију рада CYK алгоритма са ``start'' модификацијом на примеру. Нека имамо правила {\tt RG $\to$ B} и {\tt BB $\to$ W} и нека је стринг {\tt S = ``RGB''}.\\

\pagebreak

\noindent Модификован скуп правила:\\
{\tt RG $\to$ B \\ BB $\to$ W \\ \verb|^|W $\to$ \verb|^|}\\
\linebreak
\noindent Модификован стринг S:\\
{\tt \verb|^|RGB}\\
\linebreak
\noindent Приказ табеле DP на овом примеру (како није згодно цртати тродимензионе табеле, у овој илустрацији се у {\tt DP[i][j]} налазе сви симболи за које је {\tt DP[i][j][k] =} \textit{true}): \\
\linebreak
\begin{tabular}{ c | c | c | c | c }
\backslashbox{i}{j} & 1 & 2 & 3 & 4 \\ \hline
1 & \verb|^| & R & G & B \\ \hline
2 & / & B & / &  \\ \hline
3 & / & W &  &  \\ \hline
4 & {\bf \verb|^|} &  &  &  \\ 
\end{tabular}
\linebreak
\linebreak
\linebreak
Симбол \verb|^| се налази у {\tt DP[4][1]} из чега закључујемо да је одговор {\bf ``YES''}. \\
\linebreak
\noindent Илустрација (са леве стране се налази стринг као и скуп правила, а са десне су приказане ``поделе'' које доводе до решења и које одговарају правилима која треба применити да би се до решења дошло:\\
\linebreak
\includegraphics[]{img.png}
\linebreak
\noindent {\bf Субоптимална решења:}\\
\linebreak
Сада када знамо оптимално решење задатка, осврнимо се на нека субоптимална решења:
\begin{itemize}
\item {\bf Brute-force приступ}, који у овом случају подразумева да покушамо да применимо све могуће секвенце правила за мешање боја. Стандардна имплементација овог приступа би рекурзивно на тренутни низ боја примењивала сва правила која је могуће применити. Сложеност овог приступа је $\mathcal{O}((nm)^n, valjda, nemam blage)$ и очекиван број поена који би овај приступ донео је $20-40$.
\item {\bf Greedy приступи}, који подразумевају да у сваком тренутку примењујемо правила на две најлевље тј. најдешње боје. Сложеност овог приступа је $\mathcal{O}(nm)$ и очекиван број поена који би овај приступ донео је $20-40$.
\item {\bf Недетерминистички приступи и хеуристике}, тј. примена насумичних правила како би се дошло до траженог низа белих боја и коришћење одређених претпоставки и алгоритама који не морају бити увек тачни али се претпоставља да покривају одређени број случајева. Сложеност и успех оваквих приступа варира. Међу такмичарским решењима није примећена успешна примена насумичних правила без претпоставки (ни имплементације твораца овог задатка не успевају да буде боље од \textit{Brute-force} приступа), али је примећено пар делимично успешних хеуристичних приступа. [ovde popuniti] Један од њих се ослања на Џ и претпоставља Џ и освојио је Џ поена.
\item {\bf ``Компресија''}: Решење које користи CYK алгоритам али као модификацију додаје правило {\tt WW $\to$ W}. Ово решење, иако на први поглед делује као да решава проблем низа и ради за велики број насумичних тест примера, није исправно. Најпростији пример на коме се види неисправност овог приступа је:\\
\linebreak
2\\
AW $\to$ X\\
XB $\to$ W\\
1\\
4\\
AWWB\\
\linebreak
\noindent Приметимо да овде свођење на низ белих боја није могућe иако би ``компресија'' то успешно урадила ({\tt AWWB $\to$ AWB $\to$ XB $\to$ W}). Ово решење осваја $25$ поена.
\end{itemize} 

\noindent {\bf Тестирање:}\\
Тест корпус овог проблема садржи $20$ тест примера, где сваки доноси $5$ поена. У свим тест примерима важи да је {\tt t = 10}. Већина примера генерисана је аутомaтски на следећи начин:
\begin{itemize}
	\item Генерише се насумичан скуп правила за дате параметре
	\item Насумично се врши примена правила (тачније, инверзних правила {\tt C $\to$ AB}) на низ белих боја како би се добили низови за које је решење "YES"
	\item Насумично се врши додавање и премештање боја на низ добијен у претходном кораку како би се добили низови за које је решење "NO"
\end{itemize}
Параметри коришћени у генератору тест примера:
\begin{itemize}
	\item {\bf grammar\_size} - Природан број у опсегу $[1..100]$, величина скупа правила ({\tt m})
	\item {\bf max\_strlen} - Природан број у опсегу $[1..100]$, максимална дужина низа боја ({\tt n})
	\item {\bf letters\_used} - Природан број у опсегу $[4..26]$, број различитих слова енглеског алфабета који се у том тест примеру појављује
	\item {\bf force\_strlen }- Карактер из скупа $['f', 'n']$, oзначава да ли ће сви низови дати у тест примеру бити тачно дужине {\bf max\_strlen}
\end{itemize}
Поред примера генерисаних генератором додато је и неколико ручно осмишљених примера, који би требало да покрију примећене граничне случајеве. Такође, како је генератор превише наклоњен неисправном решењу ``компресија'', било је неопходно понекад ручно додавати примере, како би то решење дало нетачан резултат. У наредној табели је дат преглед тест примера ({\bf тип} = тип тест примера (аутоматски генерисан, мануелно написан), {\bf compress} = на овом тест примеру пролази ``компресијa''). Пример под бројем 0 је дат у тексту задатка, а при тестирању су коришћени тест примери 1 - 20:\\
\begin{tabular}{ c || c | c | c | c | c | c }
р. бр. & тип & grammar\_size & max\_strlen & letters\_used & force\_strlen & compress \\
\hline
0 & manual & 2 & 9 & 4 & / & да \\
1 & auto & 11 & 10 & 5 & n & не \\
2 & auto & 11 & 10 & 26 & n & не \\
3 & auto & 100 & 10 & 26 & n & не \\
4 & auto & 11 & 100 & 26 & n & не \\
5 & auto & 41 & 40 & 26 & n & не \\
6 & auto & 41 & 70 & 26 & n & не \\
7 & auto & 74 & 40 & 26 & n & не \\
8 & auto & 70 & 70 & 5 & f & да \\
9 & auto & 71 & 70 & 26 & f & не \\
10 & auto & 41 & 100 & 26 & n & не \\
11 & auto & 100 & 40 & 26 & n & не \\
12 & auto & 70 & 100 & 26 & n & не \\
13 & auto & 100 & 70 & 26 & n & не \\
14 & auto & 100 & 100 & 5 & f & не \\
15 & auto & 100 & 100 & 26 & f & не \\
16 & auto & 100 & 100 & 26 & f & не \\
17 & manual & 1 & 100 & 4 & / & да \\
18 & manual & 1 & 100 & 6 & / & да \\
19 & auto & 2 & 100 & 3 & n & да \\
20 & auto & 3 & 2 & 5 & n & не \\
\end{tabular}
\\
\linebreak
\linebreak
\noindent {\bf Статистика:}\\
\linebreak
\noindent [kasnije] Mаксималан број поена на овом задатку има само X такмичара, док је укупно Y такмичара освојило бар неке поене. Просек и још неке статистике не знам баш које. То ће бити обрађено након краја квалификација тако да ћу тада да упечујем. Неки графици рецимо. Можда на једном месту за све задатке, на почетку билтена.
\end{document}
